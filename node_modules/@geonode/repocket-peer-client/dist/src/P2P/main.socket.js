"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MainSocket = void 0;
const P2P_service_1 = require("../services/P2P.service");
const net_1 = require("net");
const events_1 = __importDefault(require("events"));
const debounce_1 = require("debounce");
const request_handler_socket_1 = require("./request-handler.socket");
const helpers_1 = require("./helpers");
const settings_1 = __importDefault(require("../shared/settings"));
class RPSocket extends net_1.Socket {
}
class MainSocket {
    constructor({ port, ip, peerId, token, userId, socketReqHandlerPort }) {
        this.MAX_SOCKET_RETRIES = 10; // try to recconnect for 1min
        this.emitter = new events_1.default();
        this.isReconnecting = false;
        this.onConnectionEstablishedEventFired = false;
        this.peerCloseWithError = false;
        this.standByHandlerSockets = [];
        this._ip = ip;
        this._port = port;
        this._socketReqHandlerPort = socketReqHandlerPort;
        this._peerId = peerId;
        this._token = token;
        this._userId = userId;
        this.resetConnectionDebounce = (0, debounce_1.debounce)(async () => {
            if (this.isReconnecting)
                return;
            if (this.mainSocket?.retryConnectionCounter < this.MAX_SOCKET_RETRIES) {
                this.mainSocket.setKeepAlive(true);
                this.mainSocket.setNoDelay(true);
                this.mainSocket.retryConnectionCounter++;
                console.log('MainSocket -> before re connect', this._ip);
                try {
                    this.isReconnecting = true;
                    this.mainSocket.connect(this._port, this._ip, () => {
                        console.log('main socket re connected');
                        this.mainSocket.isBusy = false;
                        this.mainSocket.retryConnectionCounter--;
                        this.isReconnecting = false;
                        this.peerCloseWithError = false;
                    });
                }
                catch (e) {
                    console.log('main socket re connect error', e);
                    this.onMainSocketCloseWIthError();
                    // this.mainSocket.destroy(new Error('End socket - fail to reconnect'));
                }
            }
            else {
                console.log('main socket dont renew connection');
                this.onMainSocketCloseWIthError();
                // this.mainSocket.destroy(
                //   new Error('End socket - dont renew connection - too many sockets')
                // );
                this.emitter.emit(P2P_service_1.P2PEvents.onSocketConnectionClose, null, null);
            }
        }, 500);
    }
    onMainSocketCloseWIthError() {
        this.peerCloseWithError = true;
        this.mainSocket.end();
        this.standByHandlerSockets.forEach(reqHandlerSocket => {
            reqHandlerSocket.end();
        });
        this.standByHandlerSockets = [];
    }
    end() {
        console.log('main socket destroy');
        this.onMainSocketCloseWIthError();
    }
    async connect() {
        try {
            this.mainSocket = new RPSocket();
            this.mainSocket.retryConnectionCounter = 0;
            this.mainSocket.type = 'main';
            this.mainSocket.uid = Math.random();
            this.mainSocket.isBusy = false;
            this.mainSocket.setKeepAlive(true);
            this.mainSocket.setNoDelay(true);
            this.mainSocket.on('data', async (data) => {
                await this.onData(data);
            });
            this.mainSocket.on('error', (error) => {
                console.log('MainSocket -> error', error);
                this.peerCloseWithError = true;
                this.onError(error);
            });
            this.mainSocket.on('close', (hadError) => {
                console.log('MainSocket -> close', hadError);
                this.onClose(hadError);
            });
            this.mainSocket.connect(this._port, this._ip);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    async _handleRead(data) {
        const request = String.fromCharCode(...new Uint8Array(data.buffer));
        const reqAsStr = request.toString();
        const isAuthPacket = reqAsStr == P2P_service_1.PeerSocketEvents.Authentication;
        const isPingPacket = reqAsStr == P2P_service_1.PeerSocketEvents.Ping;
        const isAuthFailedPacket = reqAsStr == P2P_service_1.PeerSocketEvents.AuthenticationFailed;
        const isConnCompletedPacket = reqAsStr == P2P_service_1.PeerSocketEvents.ConnectionCompleted;
        const isSettingsPacket = reqAsStr.toString().startsWith('settings:');
        if (isAuthPacket) {
            console.log('P2PS-MainSocket -> Authentication');
            this.mainSocket.write(`authentication ${this._token} ${this._userId} ${this._peerId}`);
            return;
        }
        else if (isConnCompletedPacket) {
            if (this.onConnectionEstablishedEventFired)
                return;
            this.emitter.emit(P2P_service_1.P2PEvents.onConnectionEstablished, null, this._peerId);
            this.onConnectionEstablishedEventFired = true;
            this.mainSocket.write(P2P_service_1.PeerSocketEvents.GetSettings);
            // RPLogger.log('P2PS-MainSocket -> authorization COMPLETED');
            return;
        }
        else if (isSettingsPacket) {
            console.log('P2PS-MainSocket -> Settings Packet : ', reqAsStr.toString());
            const settings = reqAsStr.toString().split(':')[1];
            const [reusableMode, standByMode, numberOfStandBySockets] = settings.split(',');
            settings_1.default.set({ reusableMode, standByMode, numberOfStandBySockets });
            this.initRequestHandlerStandBySockets(numberOfStandBySockets);
            return;
        }
        else if (isPingPacket) {
            console.log('MainSocket -> PING');
            this.mainSocket.write(P2P_service_1.PeerSocketEvents.Pong);
            return;
        }
        else if (isAuthFailedPacket) {
            console.log('MainSocket -> PING');
            this.onMainSocketCloseWIthError();
            // this.mainSocket.destroy(new Error('End socket - auth failed'));
            return;
        }
        const requests = reqAsStr.split('reqId:');
        if (requests && requests.length) {
            requests.forEach((reqId) => {
                if (reqId === '' || !reqId)
                    return;
                this.initRequestSocketHandler(reqId, false);
                this.initRequestSocketHandler(reqId, true);
            });
        }
    }
    initRequestHandlerStandBySockets(n) {
        for (let i = 0; i < n; i++) {
            const handler = this.initRequestHandlerStandByWaitingMode();
            this.standByHandlerSockets.push(handler);
        }
    }
    initRequestHandlerStandByWaitingMode() {
        const write = (event, reqId) => (0, helpers_1.writeToSocket)(this.mainSocket, `${event}:${reqId}`);
        const handler = new request_handler_socket_1.RequestHandlerSocket(this._ip, this._socketReqHandlerPort || 7072, null, this._peerId, true, true, true);
        handler.emitter.on(P2P_service_1.P2PEvents.onSocketConnectionFailed, (reqId) => write(P2P_service_1.PeerSocketEvents.SocketHandlerConnectionFailed, reqId));
        handler.emitter.on(P2P_service_1.P2PEvents.onTargetWebsiteError, (reqId) => write(P2P_service_1.PeerSocketEvents.TargetWebsiteError, reqId));
        handler.connect();
        return handler;
    }
    initRequestSocketHandler(reqId, standByMode = false) {
        const write = (event) => (0, helpers_1.writeToSocket)(this.mainSocket, `${event}:${reqId}`);
        const reqHandlerSocket = new request_handler_socket_1.RequestHandlerSocket(this._ip, this._socketReqHandlerPort || 7072, reqId, this._peerId, standByMode);
        reqHandlerSocket.emitter.on(P2P_service_1.P2PEvents.onSocketConnectionFailed, () => write(P2P_service_1.PeerSocketEvents.SocketHandlerConnectionFailed));
        reqHandlerSocket.emitter.on(P2P_service_1.P2PEvents.onTargetWebsiteError, () => write(P2P_service_1.PeerSocketEvents.TargetWebsiteError));
        reqHandlerSocket.connect();
    }
    async onData(data) {
        try {
            await this._handleRead(data);
        }
        catch (e) {
        }
    }
    onError(error) {
        this.peerCloseWithError = true;
        this.emitter.emit(P2P_service_1.P2PEvents.onSocketConnectionFailed, null, error);
    }
    onClose(hadError) {
        console.log('doneHandler', hadError);
        // !hadError
        if (!this.peerCloseWithError) {
            console.log('main socket try to re connect ', this._peerId);
            this.resetConnectionDebounce();
        }
        else {
            console.log('main socket dont renew connection cause of error');
            this.mainSocket.end();
            // this.mainSocket.destroy(
            //   new Error('End socket - dont renew connection - had error')
            // );
            this.emitter.emit(P2P_service_1.P2PEvents.onSocketConnectionClose, null, null);
        }
    }
}
exports.MainSocket = MainSocket;
