"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestHandlerSocket = void 0;
const net_1 = __importStar(require("net"));
const P2P_service_1 = require("../services/P2P.service");
const events_1 = __importDefault(require("events"));
const target_socket_1 = require("./target.socket");
const helpers_1 = require("./helpers");
const socks5_socket_1 = require("./socks5/socks5.socket");
const settings_1 = __importDefault(require("../shared/settings"));
// @ts-ignore
class ReqHandlerSocket extends net_1.default.Socket {
}
class RequestHandlerSocket {
    constructor(ip, port, reqId, peerId, standBy = false, standByWaitingMode = false, shouldReconnect = false) {
        this.emitter = new events_1.default();
        this.isSocks5Req = false;
        this.isConnectedToSocketServer = false;
        this.retriesConnectionCounter = 0;
        this.maxRetries = 5;
        this.delayBetweenRetries = 1000;
        this.standBy = false;
        this.standByWaitingMode = false;
        this.shouldReconnect = false;
        this._ip = ip;
        this._port = port;
        this._reqId = reqId;
        this._peerId = peerId;
        this.standBy = standBy;
        this.standByWaitingMode = standByWaitingMode;
        this.shouldReconnect = shouldReconnect;
    }
    connect() {
        // if peer pass standby mode but standby mode is off
        if (this.standBy && !settings_1.default.settings.is_stand_by_socket_mode_on)
            return;
        this.socket = new net_1.Socket();
        this.socket.retryConnectionCounter = 0;
        this.socket.type = 'handler';
        this.socket.uid = Math.random();
        this.socket.isBusy = false;
        this.socket.setNoDelay(true);
        if (this.isReusableModeActive())
            this.socket.setKeepAlive(true);
        this.socket.on('data', async (data) => {
            await this.onData(data);
        });
        this.socket.on('error', (error) => {
            this.onError(error);
        });
        this.socket.on('timeout', () => {
            console.log('Socket timeout');
            this.socket.emit('error', new Error('Timeout occurred'));
            this.socket.end();
        });
        this.socket.on('close', (hadError) => {
            this.onClose(hadError);
        });
        this.connectToSocketServer();
    }
    connectToSocketServer() {
        this.socket.connect(this._port, this._ip, () => {
            this.isConnectedToSocketServer = true;
            // console.log(`new socket req - ${this._reqId}`);
        });
    }
    reset() {
        this.targetSocket = null;
        this.socks5targetSocket = null;
        this.socket.removeAllListeners('drain');
        this.markSocketAsFree();
    }
    // socketServer: RPSocket,
    async httpProtocolHandler(data, buffer) {
        const request = this.parseHttpRequest(data);
        if (!request)
            return;
        try {
            // console.log('init new target socket for -> ', this._reqId);
            this.targetSocket = new target_socket_1.TargetSocket(this.socket, request, buffer);
            this.targetSocket.emitter.on(P2P_service_1.P2PEvents.onTargetWebsiteError, (e) => this.emitter.emit(P2P_service_1.P2PEvents.onTargetWebsiteError, null, e));
            this.targetSocket.emitter.on(P2P_service_1.P2PEvents.onTargetSocketEnd, () => {
                this.reset();
            });
            this.targetSocket.connect();
        }
        catch (e) {
            console.log('e :', e);
            return;
        }
    }
    isReusableModeActive() {
        return settings_1.default.settings.is_reusable_socket_mode_on;
    }
    async _handleRead(data) {
        // authentication
        const request = String.fromCharCode(...new Uint8Array(data.buffer));
        const reqAsStr = request.toString();
        const isAuthPacket = reqAsStr == P2P_service_1.PeerSocketEvents['Authentication'];
        const isRemoteSocketClosePacket = reqAsStr == P2P_service_1.PeerSocketEvents['RemoteSocketClosed'];
        const httpFirstLineRegex = /^(GET|HEAD|POST|PUT|DELETE|OPTIONS|TRACE|PATCH|CONNECT) (\S+\s+HTTP\/1\.(0|1)(\r\n([A-Za-z0-9-_]+:\s+[\S ]+)?)+\r\n\r\n.*)*$/;
        if (isAuthPacket) {
            this.socket.write(`authentication ${this._peerId} ${this._reqId} ${this.isReusableModeActive() ? 1 : 0} ${this.getStandByMode()}`);
            return;
        }
        else if (isRemoteSocketClosePacket) {
            if (this.targetSocket != null) {
                this.targetSocket.socket.end();
            }
            return;
        }
        else if (this.targetSocket != null) {
            try {
                // console.log('buffer size -> ', data.buffer.byteLength);
                // if (data.buffer.byteLength == 25) {
                //   console.log('data -> ', data.toString())
                // }
                this.targetSocket.lastPacket = data;
                (0, helpers_1.writeToSocket)(this.targetSocket.socket, data);
            }
            catch (e) {
                console.log('e :', e);
            }
            return;
        }
        else if (this.isSocks5Req) {
            // write events handled by pipe method on the socket for socks5
            return;
        }
        if (request.toString().startsWith('CONNECT') ||
            request.toString().includes('HTTP/1.1') ||
            request.toString().includes('HTTP/1.0') ||
            httpFirstLineRegex.test(request.toString())) {
            // http/https
            // this.socket.isBusy = true;
            return await this.httpProtocolHandler(request, data);
        }
        else if (this.isSocks5Request(data)) {
            // socks5
            this.isSocks5Req = true;
            this.socks5targetSocket = new socks5_socket_1.Socket5Handler(this.socket, {});
            this.socks5targetSocket.handle(data).then();
        }
    }
    markSocketAsFree() {
        if (!this.targetSocket && this.socket.readyState === 'open') {
            setTimeout(() => {
                this.socket.write(P2P_service_1.PeerSocketEvents.PeerSocketFree);
            }, 0);
        }
    }
    getStandByMode() {
        if (this.standByWaitingMode)
            return 2;
        if (this.standBy)
            return 1;
        return 0;
    }
    isSocks5Request(buffer) {
        if (!buffer)
            return;
        // Check if buffer length is at least 10 bytes || Check SOCKS version || Check command code || Check reserved byte
        if (buffer.length < 10 ||
            buffer[0] !== 5 ||
            buffer[1] !== 1 ||
            buffer[2] !== 0) {
            return false;
        }
        return true;
    }
    async onData(data) {
        try {
            await this._handleRead(data);
        }
        catch (e) {
            console.log('e :', e);
        }
    }
    async retry() {
        this.retriesConnectionCounter++;
        setTimeout(() => {
            this.connectToSocketServer();
        }, this.delayBetweenRetries);
    }
    shouldRetry() {
        return !this.isConnectedToSocketServer && this.retriesConnectionCounter < this.maxRetries;
    }
    onError(error) {
        if (this.shouldRetry()) {
            this.retry().then();
        }
        else {
            console.log(`onError: error when connecting to socket-server: ${error}`);
            this.emitter.emit(P2P_service_1.P2PEvents.onSocketConnectionFailed, null, error);
            this.socket.end();
            return;
        }
    }
    onClose(hadError) {
        if (this.shouldReconnect && !hadError) {
            this.reset();
            this.connect();
        }
    }
    end() {
        this.shouldReconnect = false;
        this.socket.end();
    }
    parseHttpRequest(data) {
        try {
            const regex = /^(GET|HEAD|POST|PUT|DELETE|OPTIONS|TRACE|PATCH|CONNECT)\s+(https?:\/\/)?(?:\[((?:[0-9a-fA-F:]+))\]|([\w\.-]+))(?::(\d+))?(\/\S*)?\s+HTTP\/1\.[01]$/;
            let host, port, path, method, httpVersion, protocol;
            // console.log(data)
            const splitted = data.split('\r\n');
            for (let line of splitted) {
                const match = line.match(regex);
                if (match) {
                    host = match[3] || match[4];
                    method = match[1];
                    port = match[5] || (match[2] === 'http://' ? '80' : '443');
                    path = match[6] || '/';
                    break; // Break after finding the first match
                }
            }
            const firstLine = splitted[0].trim().split(' ');
            method ||= firstLine[0];
            path ||= firstLine[1];
            httpVersion = firstLine[2];
            if (!host || !port)
                return this.parseHttpRequestByHeaders(data);
            return {
                method,
                path,
                httpVersion,
                host,
                port: port?.toString() || '80',
            };
        }
        catch (e) {
            console.log('e parseHttpRequest:', e);
            return null;
        }
    }
    parseHttpRequestByHeaders(data) {
        try {
            if (data && data.includes('HTTP/1.0')) {
                return this.parseHttpVer10(data);
            }
            const getPort = (host_header) => {
                var port;
                if (host_header.split(':').length > 2) {
                    port = Number(host_header.split(':')[2].trim());
                }
                return (port || 80).toString();
            };
            const getHostIndex = (splitted) => {
                return splitted.findIndex((l) => l.toLowerCase().includes('host:') &&
                    l.toLowerCase().startsWith('host: '));
            };
            const splitted = data.split('\r\n');
            const firstLine = splitted[0].trim().split(' ');
            const method = firstLine[0];
            const path = firstLine[1];
            const httpVersion = firstLine[2];
            const index = getHostIndex(splitted);
            const host = splitted[index].split(':')[1].trim();
            const port = getPort(splitted[index]);
            return {
                method,
                path,
                httpVersion,
                host,
                port,
            };
        }
        catch (e) {
            console.log('e parseHttpRequest:', e);
            return null;
        }
    }
    parseHttpVer10(data) {
        const splitted = data.split(' ');
        return {
            method: splitted[0],
            path: splitted[1].split(':')[0],
            httpVersion: splitted[2].split('\r')[0],
            host: splitted[1].split(':')[0],
            port: splitted[1].split(':')[1],
        };
    }
}
exports.RequestHandlerSocket = RequestHandlerSocket;
