import net, { Socket } from 'net';
import { P2PEvents, PeerSocketEvents } from '../services/P2P.service';
import EventEmitter from 'events';
import { TargetSocket } from './target.socket';
import { writeToSocket } from './helpers';
import { Socket5Handler } from './socks5/socks5.socket';
import globalSettings from "../shared/settings";

// @ts-ignore

class ReqHandlerSocket extends net.Socket {
  uid?: number;
  retryConnectionCounter?: number;
  isBusy?: boolean;
  type?: 'main' | 'helper' | string;
}

export class RequestHandlerSocket {
  emitter = new EventEmitter();
  _ip;
  _port;
  _reqId;
  _peerId;
  socket: ReqHandlerSocket;
  targetSocket: TargetSocket | null;
  socks5targetSocket: Socket5Handler | null;
  private isSocks5Req = false;
  private isConnectedToSocketServer = false;
  private retriesConnectionCounter = 0;
  private maxRetries = 5;
  private delayBetweenRetries = 1000;
  private standBy = false;
  private standByWaitingMode = false;
  private shouldReconnect = false;

  constructor(ip, port, reqId, peerId, standBy = false, standByWaitingMode = false, shouldReconnect = false) {
    this._ip = ip;
    this._port = port;
    this._reqId = reqId;
    this._peerId = peerId;
    this.standBy = standBy;
    this.standByWaitingMode = standByWaitingMode;
    this.shouldReconnect = shouldReconnect;
  }

  connect() {
    // if peer pass standby mode but standby mode is off
    if (this.standBy && !globalSettings.settings.is_stand_by_socket_mode_on) return

    this.socket = new Socket();
    this.socket.retryConnectionCounter = 0;
    this.socket.type = 'handler';
    this.socket.uid = Math.random();
    this.socket.isBusy = false;
    this.socket.setNoDelay(true);

    if (this.isReusableModeActive()) this.socket.setKeepAlive(true);


    this.socket.on('data', async (data) => {
      await this.onData(data);
    });

    this.socket.on('error', (error) => {
      this.onError(error);
    });

    this.socket.on('timeout', () => {
      console.log('Socket timeout');
      this.socket.emit('error', new Error('Timeout occurred'));
      this.socket.end();
    });

    this.socket.on('close', (hadError) => {
      this.onClose(hadError);
    });

    this.connectToSocketServer();
  }

  private connectToSocketServer() {
    this.socket.connect(this._port, this._ip, () => {
      this.isConnectedToSocketServer = true;
      // console.log(`new socket req - ${this._reqId}`);
    });
  }

  reset() {
    this.targetSocket = null;
    this.socks5targetSocket = null;
    this.socket.removeAllListeners('drain');
    this.markSocketAsFree();
  }


  // socketServer: RPSocket,
  async httpProtocolHandler(data, buffer) {
    const request = this.parseHttpRequest(data);
    if (!request) return;

    try {
      // console.log('init new target socket for -> ', this._reqId);
      this.targetSocket = new TargetSocket(this.socket, request, buffer);

      this.targetSocket.emitter.on(P2PEvents.onTargetWebsiteError, (e) =>
        this.emitter.emit(P2PEvents.onTargetWebsiteError, null, e)
      );

      this.targetSocket.emitter.on(P2PEvents.onTargetSocketEnd, () => {
        this.reset();
      })

      this.targetSocket.connect();
    } catch (e) {
      console.log('e :', e);
      return;
    }
  }

  private isReusableModeActive() {
    return globalSettings.settings.is_reusable_socket_mode_on;
  }

  async _handleRead(data) {
    // authentication
    const request = String.fromCharCode(...new Uint8Array(data.buffer));
    const reqAsStr = request.toString();
    const isAuthPacket = reqAsStr == PeerSocketEvents['Authentication'];
    const isRemoteSocketClosePacket =
      reqAsStr == PeerSocketEvents['RemoteSocketClosed'];
    const httpFirstLineRegex =
      /^(GET|HEAD|POST|PUT|DELETE|OPTIONS|TRACE|PATCH|CONNECT) (\S+\s+HTTP\/1\.(0|1)(\r\n([A-Za-z0-9-_]+:\s+[\S ]+)?)+\r\n\r\n.*)*$/;


    if (isAuthPacket) {
      this.socket.write(`authentication ${this._peerId} ${this._reqId} ${this.isReusableModeActive() ? 1 : 0} ${this.getStandByMode()}`);
      return;
    } else if (isRemoteSocketClosePacket) {
      if (this.targetSocket != null) {
        this.targetSocket.socket.end();
      }
      return;
    } else if (this.targetSocket != null) {
      try {
        // console.log('buffer size -> ', data.buffer.byteLength);
        // if (data.buffer.byteLength == 25) {
        //   console.log('data -> ', data.toString())
        // }
        this.targetSocket.lastPacket = data;
        writeToSocket(this.targetSocket.socket, data);
      } catch (e) {
        console.log('e :', e);
      }
      return;
    } else if (this.isSocks5Req) {
      // write events handled by pipe method on the socket for socks5
      return;
    }

    if (
      request.toString().startsWith('CONNECT') ||
      request.toString().includes('HTTP/1.1') ||
      request.toString().includes('HTTP/1.0') ||
      httpFirstLineRegex.test(request.toString())
    ) {
      // http/https
      // this.socket.isBusy = true;
      return await this.httpProtocolHandler(request, data);
    } else if (this.isSocks5Request(data)) {
      // socks5
      this.isSocks5Req = true;
      this.socks5targetSocket = new Socket5Handler(this.socket, {});
      this.socks5targetSocket.handle(data).then();
    }
  }

  private markSocketAsFree() {
    if (!this.targetSocket && this.socket.readyState === 'open') {
      setTimeout(() => {
        this.socket.write(PeerSocketEvents.PeerSocketFree);
      }, 0)
    }
  }

  getStandByMode() {
    if (this.standByWaitingMode) return 2;
    if (this.standBy) return 1;
    return 0;
  }

  isSocks5Request(buffer) {
    if (!buffer) return;
    // Check if buffer length is at least 10 bytes || Check SOCKS version || Check command code || Check reserved byte
    if (
      buffer.length < 10 ||
      buffer[0] !== 5 ||
      buffer[1] !== 1 ||
      buffer[2] !== 0
    ) {
      return false;
    }

    return true;
  }

  async onData(data) {
    try {
      await this._handleRead(data);
    } catch (e) {
      console.log('e :', e);
    }
  }

  async retry() {
    this.retriesConnectionCounter++;
    setTimeout(() => {
      this.connectToSocketServer();
    }, this.delayBetweenRetries);
  }

  private shouldRetry() {
    return !this.isConnectedToSocketServer && this.retriesConnectionCounter < this.maxRetries;
  }

  onError(error) {
    if (this.shouldRetry()) {
      this.retry().then();
    } else {
      console.log(`onError: error when connecting to socket-server: ${error}`);
      this.emitter.emit(P2PEvents.onSocketConnectionFailed,null , error);
      this.socket.end();
      return;
    }
  }

  onClose(hadError) {

    if (this.shouldReconnect && !hadError) {
      this.reset();
      this.connect()
    }
  }

  end() {
    this.shouldReconnect = false;
    this.socket.end();
  }

  parseHttpRequest(data: any): {
    method: string;
    path: string;
    httpVersion: any,
    host: string;
    port: any
  } | null  {
    try {

      const regex = /^(GET|HEAD|POST|PUT|DELETE|OPTIONS|TRACE|PATCH|CONNECT)\s+(https?:\/\/)?(?:\[((?:[0-9a-fA-F:]+))\]|([\w\.-]+))(?::(\d+))?(\/\S*)?\s+HTTP\/1\.[01]$/;
      let host,port,path, method, httpVersion, protocol;

      // console.log(data)
      const splitted = data.split('\r\n');

      for (let line of splitted) {
        const match = line.match(regex);
        if (match) {
          host = match[3] || match[4];
          method = match[1];
          port = match[5] || (match[2] === 'http://' ? '80' : '443');
          path = match[6] || '/';
          break; // Break after finding the first match
        }
      }

      const firstLine = splitted[0].trim().split(' ');
      method ||= firstLine[0];
      path ||= firstLine[1];
      httpVersion = firstLine[2];

      if (!host || !port) return this.parseHttpRequestByHeaders(data);

      return {
        method,
        path,
        httpVersion,
        host,
        port: port?.toString() || '80',
      };
    } catch (e) {
      console.log('e parseHttpRequest:', e);
      return null;
    }
  }

  private parseHttpRequestByHeaders(data: any) {
    try {
      if (data && data.includes('HTTP/1.0')) {
        return this.parseHttpVer10(data);
      }

      const getPort = (host_header: string) => {
        var port;
        if (host_header.split(':').length > 2) {
          port = Number(host_header.split(':')[2].trim());
        }
        return (port || 80).toString();
      };

      const getHostIndex = (splitted: Array<string>) => {
        return splitted.findIndex(
            (l) =>
                l.toLowerCase().includes('host:') &&
                l.toLowerCase().startsWith('host: ')
        );
      };

      const splitted = data.split('\r\n');
      const firstLine = splitted[0].trim().split(' ');
      const method = firstLine[0];
      const path = firstLine[1];
      const httpVersion = firstLine[2];
      const index = getHostIndex(splitted);
      const host = splitted[index].split(':')[1].trim();
      const port = getPort(splitted[index]);

      return {
        method,
        path,
        httpVersion,
        host,
        port,
      };
    } catch (e) {
      console.log('e parseHttpRequest:', e);
      return null;
    }
  }

  private parseHttpVer10(data) {
    const splitted = data.split(' ');

    return {
      method: splitted[0],
      path: splitted[1].split(':')[0],
      httpVersion: splitted[2].split('\r')[0],
      host: splitted[1].split(':')[0],
      port: splitted[1].split(':')[1],
    };
  }

}
